<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="last-modified" content="2017-03-03 15:16:12 +0100">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- meta "search-domain" used for google site search function google_search() -->
    <meta name="search-domain" value="">
    <link rel="stylesheet" type="text/css" href="../assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/lesson.css" />
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicon-swc.ico" />
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->
    <title>HPC in a day: Parallel Estimation of Pi for Pedestrians</title>
  </head>
  <body>
    <div class="container">
      
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      
      
      <a href="https://software-carpentry.org" class="pull-left">
        <img class="navbar-logo" src="../assets/img/swc-icon-blue.svg" alt="Software Carpentry logo" />
      </a>
      

      
      <a class="navbar-brand" href="../">Home</a>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">

	
        <li><a href="../conduct/">Code of Conduct</a></li>

	
        
        <li><a href="../setup/">Setup</a></li>
        <li><a href="../reference/">Reference</a></li>
        <li class="dropdown">
          <a href="../" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Episodes <span class="caret"></span></a>
          <ul class="dropdown-menu">
            
            <li><a href="../02-01-batch-systems-101/">Batch systems and schedulers 101</a></li>
            
            <li><a href="../02-02-advanced-job-scheduling/">Working with the scheduler</a></li>
            
            <li><a href="../03-01-parallel-estimate-of-pi/">Parallel Estimation of Pi for Pedestrians</a></li>
            
            <li><a href="../03-02-mpi-for-pi/">Distributing computations among computers</a></li>
            
            <li><a href="../03-03-mapreduce-for-pi/">Searching for the answer to life, the universe and everything</a></li>
            
          </ul>
        </li>
	

	
	
        <li class="dropdown">
          <a href="../" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Extras <span class="caret"></span></a>
          <ul class="dropdown-menu">
            
          </ul>
        </li>
	

	
        <li><a href="../license/">License</a></li>
      </ul>
      <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form>
    </div>
  </div>
</nav>


<div class="row">
  <div class="col-md-1">
    <h3>
      
      <a href="../02-02-advanced-job-scheduling/"><span class="glyphicon glyphicon-menu-left" aria-hidden="true"></span><span class="sr-only">previous episode</span></a>
      
    </h3>
  </div>
  <div class="col-md-10">
    
    <h3 class="maintitle"><a href="../">HPC in a day</a></h3>
    <h1 class="maintitle">Parallel Estimation of Pi for Pedestrians</h1>
    
  </div>
  <div class="col-md-1">
    <h3>
      
      <a href="../03-02-mpi-for-pi/"><span class="glyphicon glyphicon-menu-right" aria-hidden="true"></span><span class="sr-only">next episode</span></a>
      
    </h3>
  </div>
</div>


<blockquote class="objectives">
  <h2>Overview</h2>

  <div class="row">
    <div class="col-md-3">
      <strong>Teaching:</strong> 45 min
      <br/>
      <strong>Exercises:</strong> 10 min
    </div>
    <div class="col-md-9">
      <strong>Questions</strong>
      <ul>
	
	<li><p>How do I use multiple cores on a computer to solve a problem?</p>
</li>
	
      </ul>
    </div>
  </div>

  <div class="row">
    <div class="col-md-3">
    </div>
    <div class="col-md-9">
      <strong>Objectives</strong>
      <ul>
	
	<li><p>Perform a calculation of pi using only one CPU core.</p>
</li>
	
	<li><p>Perform a calculation of pi using multiple CPU cores on one machine.</p>
</li>
	
	<li><p>Measure the runtime of both the serial and parallel version of the implementation and compare them.</p>
</li>
	
      </ul>
    </div>
  </div>

</blockquote>

<p>Lola is told that her predecessors all worked on the same project. A high performant calculation that is able to produce a high precision estimate of Pi. Even though calculating Pi can be considered a solved problem, this piece of code is used at the institute to benchmark new hardware. So far, the institute has only aquired larger single machines for each lab to act as work horse per group. But currently, need for distributed computations has arisen and hence a distributed code is needed, that yields both simplicity, efficiency and scalability.</p>

<p>The algorithm to implement is very simple. It was pioneered by <em>Georges-Louis Leclerc de Buffon</em> in <em>1733</em>.</p>

<p><img src="../tikz/estimate_pi.svg" alt="Estimating Pi with Buffon's needle" /></p>

<p>Overlay a unit square over a quadrant of a circle. Throw <code class="highlighter-rouge">m</code> random number pairs and count how many of the pairs lie inside the circle (the number pairs inside the cirlce is denoted by <code class="highlighter-rouge">n</code>). <code class="highlighter-rouge">Pi</code> is then approximated by:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>     4*m
Pi = ---
      n
</code></pre>
</div>

<p>The implementation of this algorithm using <code class="highlighter-rouge">total_count</code> random number pairs in a nutshell is given in the below program:</p>

<div class="python highlighter-rouge"><pre class="highlight"><code>import numpy

np.random.seed(2017)

def inside_circle(total_count):
    
    x = np.float32(np.random.uniform(size=total_count))
    y = np.float32(np.random.uniform(size=total_count))

    radii = np.sqrt(x*x + y*y)

    count = len(radii[np.where(radii&lt;=1.0)])
    
    return count 
    
def estimate_pi(total_count):

    return (4.0 * inside_circle(total_count) / total_count) 
    
</code></pre>
</div>

<p>This code is already written in a way to allow later reuse in parallel applications. So don’t mind the two-fold indirection where <code class="highlighter-rouge">estimate_pi</code> calls <code class="highlighter-rouge">inside_circle</code>. For generating pseudo-random numbers, we sample the uniform probability distribution in the default floating point interval from <code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">1</code>. The <code class="highlighter-rouge">sqrt</code> step is not required directly, but Lola includes it here for clarity. <code class="highlighter-rouge">numpy.where</code> is used obtain the list of indices that correspond to radii which are equal or smaller than <code class="highlighter-rouge">1.0</code>. At last, this list of indices is used to filter-out the numbers in the <code class="highlighter-rouge">radii</code> array and obtain its length, which is the number Lola are after.</p>

<blockquote>
  <h2 id="editing-a-file-on-a-remote-machine">Editing a file on a remote machine</h2>
  <p>If you are following the materials closely, this is the time where you might want to edit a file on your cluster and paste the contents of the code snippet above into it. The question is, how to do that?</p>

  <p>You have several options:</p>
  <ol>
    <li>run a editor inside the <code class="highlighter-rouge">ssh</code> session that you opened to work on the cluster (mostly vi/vim, emacs, nano or pico are programs commonly installed on HPC machines)</li>
    <li>connect to the cluster with <code class="highlighter-rouge">ssh</code> using the ssh <code class="highlighter-rouge">-X</code> switch, if done so, you can open editors like emacs, nedit, gedit, … that are capable of spinning up a GUI (careful though, the GUI contents need to be transmitted through the network from the cluster to your workstation or laptop and vice verse, so in case you have a poor network connection, this approach can be visually painful)</li>
    <li>use remote editing capabilities of your preferred editor or IDE (emacs and vim has a built-in packages for this, check your preferred IDE manual for details)</li>
    <li>have a folder of your remote host mounted on your laptop (the details depend on the remote cluster and you should get in touch with the admin to find out what technologies are available), edit the files inside this folder (most of the time they are updated to the clsuter in real-time) and launch the applications from your <code class="highlighter-rouge">ssh</code> session</li>
  </ol>
</blockquote>

<p>Lola finishes writing the pi estimation and comes up with a <a href="code/03_parallel_jobs/serial_numpi.py">small python script</a>, that she can launch from the command line:</p>

<div class="bash highlighter-rouge"><pre class="highlight"><code>$ python3 ./serial_numpi.py 1000000000
</code></pre>
</div>

<div class="output highlighter-rouge"><pre class="highlight"><code>[serial version] required memory 11444.092 MB
[serial version] pi is 3.141557 from 1000000000 samples
</code></pre>
</div>

<p>She must admit that the application takes quite long to finish. Yet another reason to use a cluster or any other remote resource for these kind of applications that take quite a long time. But not everyone has a cluster at his or her disposal. So she decides to parallelize this algorithm first so that it can exploit the number cores that each machine on the cluster or even her laptop has to offer.</p>

<p>One of the many ways of making a program faster, is trying to compute as many independent parts as possible in parallel. In this case here, we can make the observation that each pair of numbers in <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> is independent of each other.</p>

<p><img src="../tikz/data_parallel_estimate_pi.svg" alt="Illustration of drawing random number pairs `x` and `y` and their dependency" /></p>

<p>Keeping this in mind, splitting up the work for multiple cores requires Lola to split up the number of total samples by the number of cores available and calling <code class="highlighter-rouge">count_inside</code> on each of these partitions.</p>

<p><img src="../tikz/partition_data_parallel_estimate_pi.svg" alt="Partitioning `x` and `y`" /></p>

<p>The number of partitions has to be limited by the number of CPU cores available. With this in mind, the <code class="highlighter-rouge">estimate_pi</code> method can be converted to run in parallel:</p>

<div class="python highlighter-rouge"><pre class="highlight"><code>from multiprocessing import Pool

def estimate_pi(n_samples,n_cores):

    partitions = [ ]
    for i in range(n_cores):
        partitions.append(int(n_samples/n_cores))

    pool = Pool(processes=n_cores)
    counts=pool.map(inside_circle, partitions)

    total_count = sum(partitions)
    return (4.0 * sum(counts) / total_count)

</code></pre>
</div>

<p>We are using the <code class="highlighter-rouge">multiprocessing</code> module that comes with the python standard library. The first step is to create a list of numbers that contain the partitions. For this, <code class="highlighter-rouge">n_samples</code> is divided by the number of cores available on the machine, where this code is executed. The ratio has to be converted to an integer to ensure, that each partition is compatible to a length of an array. The construct used next is a process <code class="highlighter-rouge">Pool</code>. Due to technical details on how the python interpreter is built, we do not use a Pool of threads here. In other languages than python, <code class="highlighter-rouge">threads</code> are the more common idiom to represent independent strings of execution that share the same memory than the process they are created in. The process <code class="highlighter-rouge">Pool</code> creates <code class="highlighter-rouge">n_cores</code> processes and keeps them active as long as the <code class="highlighter-rouge">Pool</code> is active. Then <code class="highlighter-rouge">pool.map</code> will call <code class="highlighter-rouge">inside_circle</code> using an item of <code class="highlighter-rouge">partitions</code> as the argument. In other words, for each item in <code class="highlighter-rouge">partitions</code>, the <code class="highlighter-rouge">inside_circle</code> function is called once using the respective item as input argument. The result of these invocations of <code class="highlighter-rouge">inside_circle</code> are stored within the <code class="highlighter-rouge">counts</code> variable (which will have the same length as <code class="highlighter-rouge">partitions</code> eventually).</p>

<p><img src="../tikz/partition_data_parallel_estimate_pi_with_results.svg" alt="Partitioning `x` and `y` and results of reach partition" /></p>

<p>The last step required before calculating pi is to collect the individual results from the <code class="highlighter-rouge">partitions</code> and <em>reduce</em> it to one <code class="highlighter-rouge">total_count</code> of those random number pairs that were inside of the circle. Here the <code class="highlighter-rouge">sum</code> function loops over <code class="highlighter-rouge">partitions</code> and does exactly that. So let’s run our <a href="code/03_parallel_jobs/parallel_numpi.py">parallel implementation</a> and see what it gives:</p>

<div class="bash highlighter-rouge"><pre class="highlight"><code>$ python3 ./parallel_numpi.py 1000000000
</code></pre>
</div>

<div class="output highlighter-rouge"><pre class="highlight"><code>[parallel version] required memory 11444.092 MB
[using  20 cores ] pi is 3.141631 from 1000000000 samples
</code></pre>
</div>

<p>The good news is, the parallel implementation is correct. It estimates Pi to equally bad precision than our serial implementation. The question remains, did we gain anything? For this, Lola tries to the <code class="highlighter-rouge">time</code> system utility that can be found on all *nix installations and most certainly on compute clusters.</p>

<div class="bash highlighter-rouge"><pre class="highlight"><code>$ time python3 ./serial_numpi.py 1000000000
</code></pre>
</div>

<div class="output highlighter-rouge"><pre class="highlight"><code>[serial version] required memory 11444.092 MB
[serial version] pi is 3.141557 from 1000000000 samples

real    0m52.305s
user    0m40.444s
sys     0m11.655s
</code></pre>
</div>
<div class="bash highlighter-rouge"><pre class="highlight"><code>$ time python3 ./parallel_numpi.py 1000000000
</code></pre>
</div>
<div class="output highlighter-rouge"><pre class="highlight"><code>[parallel version] required memory 11444.092 MB
[using  20 cores ] pi is 3.141631 from 1000000000 samples

real    0m6.113s
user    1m5.676s
sys     0m17.477s
</code></pre>
</div>

<p>If the snipped from above is compared to the snippets earlier, you can see that <code class="highlighter-rouge">time</code> has been put before any other command executed at the prompt and 3 lines have been added to the output of our program. <code class="highlighter-rouge">time</code> reports 3 times and they are all different:</p>

<ul>
  <li><code class="highlighter-rouge">real</code> that denotes the time that has passed during our program as if you would have used a stop watch</li>
  <li><code class="highlighter-rouge">user</code> this is accumulated amount of CPU seconds (so seconds that the CPU was active) spent in code by the user (you)</li>
  <li><code class="highlighter-rouge">sys</code>  this is accumulated amount of CPU seconds that the CPU spent while executing system code that was necessary to run your program (memory management, display drivers if needed, interactions with the disk, etc.)</li>
</ul>

<p>So from the above, Lola wants to compare the <code class="highlighter-rouge">real</code> time spent by her serial implementation (<code class="highlighter-rouge">0m52.305s</code>) and compare it to the <code class="highlighter-rouge">real</code> time spent by her parallel implementation (<code class="highlighter-rouge">0m6.113s</code>). Apparently, her parallel program was <em>8.6</em> times faster than the serial implementation. The latter number is called the speed-up of the parallelisation. Very good for a first attempt.</p>

<blockquote class="callout">
  <h2 id="adding-up-times">Adding up times</h2>
  <p>The output of the <code class="highlighter-rouge">time</code> command is very much bound to how a operating system works. In an ideal world, <code class="highlighter-rouge">user</code> and <code class="highlighter-rouge">sys</code> of serial programs should add up to <code class="highlighter-rouge">real</code>. Typically they never do. The reason is, that the operating systems used in HPC and on laptops or workstations are set up in a way, that the operating system decices which process receives time on the CPU (aka to perform computations) when. Once a process runs, it may however happen, that the system decides to intervene and have some other binary have a tiny slice of a CPU second while your application is executed. This is where the mismatch for <code class="highlighter-rouge">user+sys</code> and <code class="highlighter-rouge">real</code> comes from.
Note also how the <code class="highlighter-rouge">user</code> time of the parallel program is a lot larger than the time that was actually consumed. This is because, time reports accumulated timings i.e. it adds up CPU seconds that were consumed in parallel.</p>
</blockquote>

<blockquote class="callout">
  <h2 id="something-is-missing">Something is missing</h2>
  <p>A speed-up of <em>8.6x</em> for a parallel python program is not bad. The luxury of python programming makes us pay the price of performance. In a perfect world, data parallel algorithms using one machine only are expected to scale perfectly, i.e. using 20 cores should give a speed-up of <em>20x</em>. Due to a myriad of reasons from the software or from the hardware side, this perfect scaling often remains a hard-to-achieve goal which projects attain only after months if not years of development.</p>
</blockquote>


<blockquote class="keypoints">
  <h2>Key Points</h2>
  <ul>
    
  </ul>
</blockquote>


<div class="row">
  <div class="col-md-1">
    <h3>
      
      <a href="../02-02-advanced-job-scheduling/"><span class="glyphicon glyphicon-menu-left" aria-hidden="true"></span><span class="sr-only">previous episode</span></a>
      
    </h3>
  </div>
  <div class="col-md-10">
    
  </div>
  <div class="col-md-1">
    <h3>
      
      <a href="../03-02-mpi-for-pi/"><span class="glyphicon glyphicon-menu-right" aria-hidden="true"></span><span class="sr-only">next episode</span></a>
      
    </h3>
  </div>
</div>


      
      
<footer>
  <div class="row">
    <div class="col-md-6" align="left">
      <h4>
	Copyright &copy; 2017
	
	<a href="https://software-carpentry.org">Software Carpentry Foundation</a>
	
      </h4>
    </div>
    <div class="col-md-6" align="right">
      <h4>
	<a href="/">Source</a>
	/
	<a href="/blob/gh-pages/CONTRIBUTING.md">Contributing</a>
	/
	<a href="/blob/gh-pages/CITATION">Cite</a>
	/
	<a href="">Contact</a>
      </h4>
    </div>
  </div>
</footer>

      
    </div>
    
<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>
<script src="../assets/js/lesson.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-37305346-2', 'auto');
  ga('send', 'pageview');
</script>

  </body>
</html>
